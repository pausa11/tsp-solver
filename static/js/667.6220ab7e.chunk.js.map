{"version":3,"file":"static/js/667.6220ab7e.chunk.js","mappings":"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","sources":["workers/tspsolverMSTWorker.worker.js","../webpack/bootstrap","../webpack/runtime/amd define","../webpack/runtime/amd options","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["/* eslint-disable no-restricted-globals */\r\n\r\nimport * as math from 'mathjs';\r\nimport { Graph } from 'graphlib';\r\nimport PriorityQueue from 'priorityqueuejs';\r\n\r\nclass DisjointSet {\r\n    constructor(size) {\r\n        this.parent = Array.from({ length: size }, (_, i) => i);\r\n        this.rank = Array(size).fill(0);\r\n    }\r\n\r\n    find(x) {\r\n        if (this.parent[x] !== x) {\r\n            this.parent[x] = this.find(this.parent[x]);\r\n        }\r\n        return this.parent[x];\r\n    }\r\n\r\n    union(x, y) {\r\n        const rootX = this.find(x);\r\n        const rootY = this.find(y);\r\n\r\n        if (rootX !== rootY) {\r\n            if (this.rank[rootX] < this.rank[rootY]) {\r\n                this.parent[rootX] = rootY;\r\n            } else if (this.rank[rootX] > this.rank[rootY]) {\r\n                this.parent[rootY] = rootX;\r\n            } else {\r\n                this.parent[rootY] = rootX;\r\n                this.rank[rootX]++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass TSP_Solver_AStar {\r\n    constructor(locations) {\r\n        this.locations = locations;\r\n        this.graph = this.createCompleteGraph(locations);\r\n        this.startNode = 0;\r\n        this.totalNodes = locations.length;\r\n        this.memoizedHeuristics = new Map();\r\n        this.timeLimit = 99000; // 15 segundos\r\n        this.startTime = Date.now();\r\n        this.bestSolution = null;\r\n        this.lastUpdate = Date.now();\r\n        this.distanceMatrix = this.createDistanceMatrix();\r\n        \r\n        // Crear array de visitados inicial\r\n        this.initialVisited = new Array(this.totalNodes).fill(false);\r\n        this.initialVisited[this.startNode] = true;\r\n    }\r\n\r\n    createDistanceMatrix() {\r\n        const matrix = Array(this.totalNodes).fill().map(() => Array(this.totalNodes));\r\n        for (let i = 0; i < this.totalNodes; i++) {\r\n            for (let j = i + 1; j < this.totalNodes; j++) {\r\n                const dist = math.distance(\r\n                    [this.locations[i].x, this.locations[i].y],\r\n                    [this.locations[j].x, this.locations[j].y]\r\n                );\r\n                matrix[i][j] = dist;\r\n                matrix[j][i] = dist;\r\n            }\r\n            matrix[i][i] = 0;\r\n        }\r\n        return matrix;\r\n    }\r\n\r\n    createCompleteGraph(locations) {\r\n        const graph = new Graph({ directed: false });\r\n        const numLocations = locations.length;\r\n\r\n        for (let i = 0; i < numLocations; i++) {\r\n            for (let j = i + 1; j < numLocations; j++) {\r\n                const dist = math.distance(\r\n                    [locations[i].x, locations[i].y],\r\n                    [locations[j].x, locations[j].y]\r\n                );\r\n                graph.setEdge(i, j, dist);\r\n            }\r\n        }\r\n        return graph;\r\n    }\r\n\r\n    getDistance(from, to) {\r\n        return this.distanceMatrix[from][to];\r\n    }\r\n\r\n    // Función para convertir array de visitados a string para usar como clave en el cache\r\n    visitedToString(visited, currentNode) {\r\n        return `${currentNode}-${visited.join('')}`;\r\n    }\r\n\r\n    // Función para obtener nodos no visitados\r\n    getUnvisitedNodes(visited) {\r\n        const unvisited = [];\r\n        for (let i = 0; i < this.totalNodes; i++) {\r\n            if (!visited[i]) {\r\n                unvisited.push(i);\r\n            }\r\n        }\r\n        return unvisited;\r\n    }\r\n\r\n    kruskalMST(unvisitedNodes) {\r\n        if (unvisitedNodes.length <= 1) return 0;\r\n        \r\n        const edges = [];\r\n        const n = unvisitedNodes.length;\r\n        \r\n        for (let i = 0; i < n; i++) {\r\n            const node1 = unvisitedNodes[i];\r\n            for (let j = i + 1; j < n; j++) {\r\n                const node2 = unvisitedNodes[j];\r\n                edges.push({\r\n                    v: node1,\r\n                    w: node2,\r\n                    weight: this.getDistance(node1, node2)\r\n                });\r\n            }\r\n        }\r\n\r\n        edges.sort((a, b) => a.weight - b.weight);\r\n        const ds = new DisjointSet(this.totalNodes);\r\n        let mstCost = 0;\r\n        let edgesUsed = 0;\r\n        const neededEdges = n - 1;\r\n\r\n        for (const edge of edges) {\r\n            if (ds.find(edge.v) !== ds.find(edge.w)) {\r\n                mstCost += edge.weight;\r\n                ds.union(edge.v, edge.w);\r\n                edgesUsed++;\r\n                if (edgesUsed === neededEdges) break;\r\n            }\r\n        }\r\n\r\n        return mstCost;\r\n    }\r\n\r\n    calculateMSTHeuristic(currentNode, visited) {\r\n        const unvisitedNodes = this.getUnvisitedNodes(visited);\r\n        if (unvisitedNodes.length === 0) return 0;\r\n\r\n        const memoKey = this.visitedToString(visited, currentNode);\r\n        const cached = this.memoizedHeuristics.get(memoKey);\r\n        if (cached !== undefined) {\r\n            return cached;\r\n        }\r\n\r\n        // Si solo queda un nodo por visitar, la heurística es la distancia directa\r\n        if (unvisitedNodes.length === 1) {\r\n            const hValue = this.getDistance(currentNode, unvisitedNodes[0]);\r\n            this.memoizedHeuristics.set(memoKey, hValue);\r\n            return hValue;\r\n        }\r\n\r\n        const mstCost = this.kruskalMST(unvisitedNodes);\r\n\r\n        // Encontrar la distancia mínima desde el nodo actual a cualquier nodo no visitado\r\n        let minToUnvisited = Infinity;\r\n        for (const node of unvisitedNodes) {\r\n            const dist = this.getDistance(currentNode, node);\r\n            if (dist < minToUnvisited) {\r\n                minToUnvisited = dist;\r\n            }\r\n        }\r\n\r\n        const heuristicValue = mstCost + minToUnvisited;\r\n        this.memoizedHeuristics.set(memoKey, heuristicValue);\r\n        return heuristicValue;\r\n    }\r\n\r\n    countVisited(visited) {\r\n        return visited.reduce((count, v) => count + (v ? 1 : 0), 0);\r\n    }\r\n\r\n    updateBestSolution(solution) {\r\n        this.bestSolution = solution;\r\n        const currentTime = Date.now();\r\n        if (currentTime - this.lastUpdate > 1000) {\r\n            this.lastUpdate = currentTime;\r\n            console.log(`Nueva mejor solución encontrada: ${solution.totalCost}`);\r\n        }\r\n    }\r\n\r\n    findInitialSolution() {\r\n        // Encuentra una solución inicial usando el vecino más cercano\r\n        const visited = new Array(this.totalNodes).fill(false);\r\n        visited[this.startNode] = true;\r\n        let currentNode = this.startNode;\r\n        const path = [this.startNode];\r\n        let totalCost = 0;\r\n        \r\n        for (let i = 1; i < this.totalNodes; i++) {\r\n            let nearestNode = -1;\r\n            let minDistance = Infinity;\r\n            \r\n            for (let j = 0; j < this.totalNodes; j++) {\r\n                if (!visited[j]) {\r\n                    const distance = this.getDistance(currentNode, j);\r\n                    if (distance < minDistance) {\r\n                        minDistance = distance;\r\n                        nearestNode = j;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            visited[nearestNode] = true;\r\n            path.push(nearestNode);\r\n            totalCost += minDistance;\r\n            currentNode = nearestNode;\r\n        }\r\n        \r\n        // Agregar el costo de retorno al nodo inicial\r\n        totalCost += this.getDistance(currentNode, this.startNode);\r\n        path.push(this.startNode);\r\n        \r\n        return {\r\n            path: path,\r\n            totalCost: totalCost\r\n        };\r\n    }\r\n\r\n    solve() {\r\n        // Encontrar una solución inicial usando el vecino más cercano\r\n        this.bestSolution = this.findInitialSolution();\r\n        console.log(`Solución inicial encontrada: ${this.bestSolution.totalCost}`);\r\n\r\n        const openSet = new PriorityQueue((a, b) => b.f - a.f);\r\n        \r\n        const startState = {\r\n            currentNode: this.startNode,\r\n            visited: [...this.initialVisited],\r\n            path: [this.startNode],\r\n            g: 0,\r\n            h: this.calculateMSTHeuristic(this.startNode, this.initialVisited),\r\n            f: 0\r\n        };\r\n        startState.f = startState.g + startState.h;\r\n\r\n        openSet.enq(startState);\r\n        let nodesExplored = 0;\r\n        let lastProgressUpdate = Date.now();\r\n\r\n        while (!openSet.isEmpty()) {\r\n            const currentTime = Date.now();\r\n            if (currentTime - this.startTime > this.timeLimit) {\r\n                console.log(`Tiempo límite alcanzado. Nodos explorados: ${nodesExplored}`);\r\n                console.log(`Mejor solución encontrada: ${this.bestSolution.totalCost}`);\r\n                return this.bestSolution;\r\n            }\r\n\r\n            // Actualizar progreso cada segundo\r\n            if (currentTime - lastProgressUpdate > 1000) {\r\n                console.log(`Progreso: ${nodesExplored} nodos explorados, mejor solución: ${this.bestSolution.totalCost}`);\r\n                lastProgressUpdate = currentTime;\r\n            }\r\n\r\n            const state = openSet.deq();\r\n            nodesExplored++;\r\n\r\n            // Verificar si hemos visitado todos los nodos\r\n            if (this.countVisited(state.visited) === this.totalNodes) {\r\n                const returnCost = this.getDistance(state.currentNode, this.startNode);\r\n                const totalCost = state.g + returnCost;\r\n                const totalPath = [...state.path, this.startNode];\r\n\r\n                if (!this.bestSolution || totalCost < this.bestSolution.totalCost) {\r\n                    this.updateBestSolution({\r\n                        path: totalPath,\r\n                        totalCost: totalCost\r\n                    });\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // Podar ramas no prometedoras\r\n            if (this.bestSolution && state.f >= this.bestSolution.totalCost * 1.1) {\r\n                continue;\r\n            }\r\n\r\n            // Explorar vecinos no visitados\r\n            for (let neighbor = 0; neighbor < this.totalNodes; neighbor++) {\r\n                if (!state.visited[neighbor]) {\r\n                    const newVisited = [...state.visited];\r\n                    newVisited[neighbor] = true;\r\n                    \r\n                    const gCost = state.g + this.getDistance(state.currentNode, neighbor);\r\n\r\n                    if (this.bestSolution && gCost >= this.bestSolution.totalCost) {\r\n                        continue;\r\n                    }\r\n\r\n                    const hCost = this.calculateMSTHeuristic(neighbor, newVisited);\r\n                    const fCost = gCost + hCost;\r\n\r\n                    if (this.bestSolution && fCost >= this.bestSolution.totalCost) {\r\n                        continue;\r\n                    }\r\n\r\n                    openSet.enq({\r\n                        currentNode: neighbor,\r\n                        visited: newVisited,\r\n                        path: [...state.path, neighbor],\r\n                        g: gCost,\r\n                        h: hCost,\r\n                        f: fCost\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Liberar memoria periódicamente\r\n            if (nodesExplored % 10000 === 0) {\r\n                if (this.memoizedHeuristics.size > 1000000) {\r\n                    this.memoizedHeuristics.clear();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.bestSolution;\r\n    }\r\n}\r\n\r\nself.onmessage = function(e) {\r\n    const { type, data } = e.data;\r\n    \r\n    if (type === 'solve') {\r\n        try {\r\n            console.log('Worker: Starting TSP solution');\r\n            const solver = new TSP_Solver_AStar(data);\r\n            const solution = solver.solve();\r\n            \r\n            // Enviar actualizaciones de progreso\r\n            const progressUpdate = {\r\n                type: 'progress',\r\n                data: {\r\n                    nodesExplored: solver.nodesExplored,\r\n                    currentBest: solver.bestSolution?.totalCost\r\n                }\r\n            };\r\n            self.postMessage(progressUpdate);\r\n            \r\n            // Enviar la solución final\r\n            self.postMessage({\r\n                type: 'solution',\r\n                data: solution\r\n            });\r\n        } catch (error) {\r\n            self.postMessage({\r\n                type: 'error',\r\n                data: error.message\r\n            });\r\n        }\r\n    }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [133], () => (__webpack_require__(6258)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","__webpack_require__.amdO = {};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"c2e388aa\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/tsp-solver/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t667: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunktsp\"] = self[\"webpackChunktsp\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(133).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DisjointSet","constructor","size","this","parent","Array","from","length","_","i","rank","fill","find","x","union","y","rootX","rootY","TSP_Solver_AStar","locations","graph","createCompleteGraph","startNode","totalNodes","memoizedHeuristics","Map","timeLimit","startTime","Date","now","bestSolution","lastUpdate","distanceMatrix","createDistanceMatrix","initialVisited","matrix","map","j","dist","math","Graph","directed","numLocations","setEdge","getDistance","to","visitedToString","visited","currentNode","join","getUnvisitedNodes","unvisited","push","kruskalMST","unvisitedNodes","edges","n","node1","node2","v","w","weight","sort","a","b","ds","mstCost","edgesUsed","neededEdges","edge","calculateMSTHeuristic","memoKey","cached","get","undefined","hValue","set","minToUnvisited","Infinity","node","heuristicValue","countVisited","reduce","count","updateBestSolution","solution","currentTime","console","log","totalCost","findInitialSolution","path","nearestNode","minDistance","distance","solve","openSet","PriorityQueue","f","startState","g","h","enq","nodesExplored","lastProgressUpdate","isEmpty","state","deq","neighbor","newVisited","gCost","hCost","fCost","clear","returnCost","totalPath","self","onmessage","e","type","data","_solver$bestSolution","solver","progressUpdate","currentBest","postMessage","error","message","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","amdD","Error","amdO","deferred","result","chunkIds","fn","priority","notFulfilled","fulfilled","Object","keys","every","key","splice","r","getter","__esModule","d","definition","o","defineProperty","enumerable","chunkId","Promise","all","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}