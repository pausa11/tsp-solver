{"version":3,"file":"static/js/613.f320904f.chunk.js","mappings":"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","sources":["workers/tspsolverAcoAndMstWorker.worker.js","../webpack/bootstrap","../webpack/runtime/amd define","../webpack/runtime/amd options","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["/* eslint-disable no-restricted-globals */\r\n\r\nimport * as math from 'mathjs';\r\nimport { Graph } from 'graphlib';\r\nimport PriorityQueue from 'priorityqueuejs';\r\n\r\nclass DisjointSet {\r\n    constructor(size) {\r\n        this.parent = Array.from({ length: size }, (_, i) => i);\r\n        this.rank = Array(size).fill(0);\r\n    }\r\n\r\n    find(x) {\r\n        if (this.parent[x] !== x) {\r\n            this.parent[x] = this.find(this.parent[x]);\r\n        }\r\n        return this.parent[x];\r\n    }\r\n\r\n    union(x, y) {\r\n        const rootX = this.find(x);\r\n        const rootY = this.find(y);\r\n\r\n        if (rootX !== rootY) {\r\n            if (this.rank[rootX] < this.rank[rootY]) {\r\n                this.parent[rootX] = rootY;\r\n            } else if (this.rank[rootX] > this.rank[rootY]) {\r\n                this.parent[rootY] = rootX;\r\n            } else {\r\n                this.parent[rootY] = rootX;\r\n                this.rank[rootX]++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass AntColony {\r\n    constructor(distanceMatrix, numAnts = 10, iterations = 5, evaporationRate = 0.1, alpha = 1, beta = 2) {\r\n        this.distanceMatrix = distanceMatrix;\r\n        this.numCities = distanceMatrix.length;\r\n        this.numAnts = numAnts;\r\n        this.iterations = iterations;\r\n        this.evaporationRate = evaporationRate;\r\n        this.alpha = alpha;\r\n        this.beta = beta;\r\n        this.pheromoneMatrix = Array(this.numCities).fill().map(() => \r\n            Array(this.numCities).fill(1.0 / this.numCities)\r\n        );\r\n        this.bestTourLength = Infinity;\r\n        this.bestTour = null;\r\n    }\r\n\r\n    runIteration(startCity, visitedNodes) {\r\n        let bestIterationLength = Infinity;\r\n\r\n        for (let ant = 0; ant < this.numAnts; ant++) {\r\n            const tour = this.constructSolution(startCity, visitedNodes);\r\n            const tourLength = this.calculateTourLength(tour);\r\n\r\n            if (tourLength < bestIterationLength) {\r\n                bestIterationLength = tourLength;\r\n            }\r\n\r\n            if (tourLength < this.bestTourLength) {\r\n                this.bestTourLength = tourLength;\r\n                this.bestTour = [...tour];\r\n            }\r\n        }\r\n\r\n        this.updatePheromones(this.bestTour, this.bestTourLength);\r\n        return bestIterationLength;\r\n    }\r\n\r\n    constructSolution(startCity, visitedNodes) {\r\n        const available = new Array(this.numCities).fill(true);\r\n        visitedNodes.forEach(node => available[node] = false);\r\n        \r\n        const tour = [startCity];\r\n        let currentCity = startCity;\r\n\r\n        while (tour.length < this.numCities - visitedNodes.length + 1) {\r\n            const nextCity = this.selectNextCity(currentCity, available);\r\n            tour.push(nextCity);\r\n            available[nextCity] = false;\r\n            currentCity = nextCity;\r\n        }\r\n\r\n        return tour;\r\n    }\r\n\r\n    selectNextCity(currentCity, available) {\r\n        const probabilities = [];\r\n        let totalProbability = 0;\r\n\r\n        for (let city = 0; city < this.numCities; city++) {\r\n            if (available[city]) {\r\n                const pheromone = Math.pow(this.pheromoneMatrix[currentCity][city], this.alpha);\r\n                const distance = 1.0 / Math.pow(this.distanceMatrix[currentCity][city], this.beta);\r\n                const probability = pheromone * distance;\r\n                probabilities.push({ city, probability });\r\n                totalProbability += probability;\r\n            }\r\n        }\r\n\r\n        let random = Math.random() * totalProbability;\r\n        let sum = 0;\r\n\r\n        for (const { city, probability } of probabilities) {\r\n            sum += probability;\r\n            if (random <= sum) {\r\n                return city;\r\n            }\r\n        }\r\n\r\n        return probabilities[probabilities.length - 1].city;\r\n    }\r\n\r\n    calculateTourLength(tour) {\r\n        let length = 0;\r\n        for (let i = 0; i < tour.length - 1; i++) {\r\n            length += this.distanceMatrix[tour[i]][tour[i + 1]];\r\n        }\r\n        return length;\r\n    }\r\n\r\n    updatePheromones(tour, tourLength) {\r\n        // Evaporación\r\n        for (let i = 0; i < this.numCities; i++) {\r\n            for (let j = 0; j < this.numCities; j++) {\r\n                this.pheromoneMatrix[i][j] *= (1 - this.evaporationRate);\r\n            }\r\n        }\r\n\r\n        // Depósito de feromonas\r\n        const pheromoneDeposit = 1.0 / tourLength;\r\n        for (let i = 0; i < tour.length - 1; i++) {\r\n            const from = tour[i];\r\n            const to = tour[i + 1];\r\n            this.pheromoneMatrix[from][to] += pheromoneDeposit;\r\n            this.pheromoneMatrix[to][from] += pheromoneDeposit;\r\n        }\r\n    }\r\n}\r\n\r\nclass HybridHeuristic {\r\n    constructor(distanceMatrix) {\r\n        this.distanceMatrix = distanceMatrix;\r\n        this.numCities = distanceMatrix.length;\r\n        this.antColony = new AntColony(distanceMatrix);\r\n        this.weightMST = 0.6;  // Peso para MST\r\n        this.weightACO = 0.4;  // Peso para ACO\r\n    }\r\n\r\n    calculateMSTCost(unvisitedNodes) {\r\n        if (unvisitedNodes.length <= 1) return 0;\r\n        \r\n        const edges = [];\r\n        const n = unvisitedNodes.length;\r\n        \r\n        for (let i = 0; i < n; i++) {\r\n            const node1 = unvisitedNodes[i];\r\n            for (let j = i + 1; j < n; j++) {\r\n                const node2 = unvisitedNodes[j];\r\n                edges.push({\r\n                    v: node1,\r\n                    w: node2,\r\n                    weight: this.distanceMatrix[node1][node2]\r\n                });\r\n            }\r\n        }\r\n\r\n        edges.sort((a, b) => a.weight - b.weight);\r\n        const ds = new DisjointSet(this.numCities);\r\n        let mstCost = 0;\r\n        let edgesUsed = 0;\r\n        const neededEdges = n - 1;\r\n\r\n        for (const edge of edges) {\r\n            if (ds.find(edge.v) !== ds.find(edge.w)) {\r\n                mstCost += edge.weight;\r\n                ds.union(edge.v, edge.w);\r\n                edgesUsed++;\r\n                if (edgesUsed === neededEdges) break;\r\n            }\r\n        }\r\n\r\n        return mstCost;\r\n    }\r\n\r\n    calculateACOCost(currentNode, visitedNodes) {\r\n        return this.antColony.runIteration(currentNode, visitedNodes);\r\n    }\r\n\r\n    getMinUnvisitedDistance(currentNode, unvisitedNodes) {\r\n        let minDistance = Infinity;\r\n        for (const node of unvisitedNodes) {\r\n            const dist = this.distanceMatrix[currentNode][node];\r\n            if (dist < minDistance) {\r\n                minDistance = dist;\r\n            }\r\n        }\r\n        return minDistance;\r\n    }\r\n\r\n    calculateHybridHeuristic(currentNode, visited) {\r\n        const visitedNodes = visited.reduce((acc, v, i) => {\r\n            if (v) acc.push(i);\r\n            return acc;\r\n        }, []);\r\n        \r\n        const unvisitedNodes = visited.reduce((acc, v, i) => {\r\n            if (!v) acc.push(i);\r\n            return acc;\r\n        }, []);\r\n\r\n        if (unvisitedNodes.length === 0) return 0;\r\n\r\n        // Calcular MST\r\n        const mstCost = this.calculateMSTCost(unvisitedNodes);\r\n        const minToUnvisited = this.getMinUnvisitedDistance(currentNode, unvisitedNodes);\r\n        const mstHeuristic = mstCost + minToUnvisited;\r\n\r\n        // Calcular ACO\r\n        const acoCost = this.calculateACOCost(currentNode, visitedNodes);\r\n\r\n        // Combinar heurísticas\r\n        return (this.weightMST * mstHeuristic + this.weightACO * acoCost);\r\n    }\r\n\r\n    // Método para ajustar los pesos dinámicamente basado en el rendimiento\r\n    adjustWeights(mstSuccess, acoSuccess) {\r\n        const adaptationRate = 0.1;\r\n        if (mstSuccess && !acoSuccess) {\r\n            this.weightMST = Math.min(0.8, this.weightMST + adaptationRate);\r\n            this.weightACO = 1 - this.weightMST;\r\n        } else if (!mstSuccess && acoSuccess) {\r\n            this.weightACO = Math.min(0.8, this.weightACO + adaptationRate);\r\n            this.weightMST = 1 - this.weightACO;\r\n        }\r\n    }\r\n}\r\n\r\nclass TSP_Solver_AStar {\r\n    constructor(locations) {\r\n        this.locations = locations;\r\n        this.graph = this.createCompleteGraph(locations);\r\n        this.startNode = 0;\r\n        this.totalNodes = locations.length;\r\n        this.memoizedHeuristics = new Map();\r\n        this.timeLimit = 99000;\r\n        this.startTime = Date.now();\r\n        this.bestSolution = null;\r\n        this.lastUpdate = Date.now();\r\n        this.distanceMatrix = this.createDistanceMatrix();\r\n        this.hybridHeuristic = new HybridHeuristic(this.distanceMatrix);\r\n        \r\n        this.initialVisited = new Array(this.totalNodes).fill(false);\r\n        this.initialVisited[this.startNode] = true;\r\n\r\n        // Para el seguimiento del rendimiento de las heurísticas\r\n        this.mstSuccesses = 0;\r\n        this.acoSuccesses = 0;\r\n        this.totalAttempts = 0;\r\n    }\r\n\r\n    createDistanceMatrix() {\r\n        const matrix = Array(this.totalNodes).fill().map(() => Array(this.totalNodes));\r\n        for (let i = 0; i < this.totalNodes; i++) {\r\n            for (let j = i + 1; j < this.totalNodes; j++) {\r\n                const dist = math.distance(\r\n                    [this.locations[i].x, this.locations[i].y],\r\n                    [this.locations[j].x, this.locations[j].y]\r\n                );\r\n                matrix[i][j] = dist;\r\n                matrix[j][i] = dist;\r\n            }\r\n            matrix[i][i] = 0;\r\n        }\r\n        return matrix;\r\n    }\r\n\r\n    createCompleteGraph(locations) {\r\n        const graph = new Graph({ directed: false });\r\n        const numLocations = locations.length;\r\n\r\n        for (let i = 0; i < numLocations; i++) {\r\n            for (let j = i + 1; j < numLocations; j++) {\r\n                const dist = math.distance(\r\n                    [locations[i].x, locations[i].y],\r\n                    [locations[j].x, locations[j].y]\r\n                );\r\n                graph.setEdge(i, j, dist);\r\n            }\r\n        }\r\n        return graph;\r\n    }\r\n\r\n    getDistance(from, to) {\r\n        return this.distanceMatrix[from][to];\r\n    }\r\n\r\n    visitedToString(visited, currentNode) {\r\n        return `${currentNode}-${visited.join('')}`;\r\n    }\r\n\r\n    calculateHeuristic(currentNode, visited) {\r\n        const memoKey = this.visitedToString(visited, currentNode);\r\n        const cached = this.memoizedHeuristics.get(memoKey);\r\n        if (cached !== undefined) {\r\n            return cached;\r\n        }\r\n\r\n        const heuristicValue = this.hybridHeuristic.calculateHybridHeuristic(currentNode, visited);\r\n        this.memoizedHeuristics.set(memoKey, heuristicValue);\r\n        \r\n        this.totalAttempts++;\r\n        if (this.totalAttempts % 100 === 0) {\r\n            this.hybridHeuristic.adjustWeights(\r\n                this.mstSuccesses / this.totalAttempts > 0.5,\r\n                this.acoSuccesses / this.totalAttempts > 0.5\r\n            );\r\n        }\r\n\r\n        return heuristicValue;\r\n    }\r\n\r\n    countVisited(visited) {\r\n        return visited.reduce((count, v) => count + (v ? 1 : 0), 0);\r\n    }\r\n\r\n    updateBestSolution(solution) {\r\n        this.bestSolution = solution;\r\n        const currentTime = Date.now();\r\n        if (currentTime - this.lastUpdate > 1000) {\r\n            this.lastUpdate = currentTime;\r\n            console.log(`Nueva mejor solución encontrada: ${solution.totalCost}`);\r\n            console.log(`Pesos actuales - MST: ${this.hybridHeuristic.weightMST.toFixed(2)}, ACO: ${this.hybridHeuristic.weightACO.toFixed(2)}`);\r\n        }\r\n    }\r\n\r\n    findInitialSolution() {\r\n        const visited = new Array(this.totalNodes).fill(false);\r\n        visited[this.startNode] = true;\r\n        let currentNode = this.startNode;\r\n        const path = [this.startNode];\r\n        let totalCost = 0;\r\n        \r\n        for (let i = 1; i < this.totalNodes; i++) {\r\n            let nearestNode = -1;\r\n            let minDistance = Infinity;\r\n            \r\n            for (let j = 0; j < this.totalNodes; j++) {\r\n                if (!visited[j]) {\r\n                    const distance = this.getDistance(currentNode, j);\r\n                    if (distance < minDistance) {\r\n                        minDistance = distance;\r\n                        nearestNode = j;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            visited[nearestNode] = true;\r\n            path.push(nearestNode);\r\n            totalCost += minDistance;\r\n            currentNode = nearestNode;\r\n        }\r\n        \r\n        totalCost += this.getDistance(currentNode, this.startNode);\r\n        path.push(this.startNode);\r\n        \r\n        return {\r\n            path: path,\r\n            totalCost: totalCost\r\n        };\r\n    }\r\n\r\n    solve() {\r\n        this.bestSolution = this.findInitialSolution();\r\n        console.log(`Solución inicial encontrada: ${this.bestSolution.totalCost}`);\r\n\r\n        const openSet = new PriorityQueue((a, b) => b.f - a.f);\r\n        \r\n        const startState = {\r\n            currentNode: this.startNode,\r\n            visited: [...this.initialVisited],\r\n            path: [this.startNode],\r\n            g: 0,\r\n            h: this.calculateHeuristic(this.startNode, this.initialVisited),\r\n            f: 0\r\n        };\r\n        startState.f = startState.g + startState.h;\r\n\r\n        openSet.enq(startState);\r\n        let nodesExplored = 0;\r\n        let lastProgressUpdate = Date.now();\r\n\r\n        while (!openSet.isEmpty()) {\r\n            const currentTime = Date.now();\r\n            if (currentTime - this.startTime > this.timeLimit) {\r\n                console.log(\"Tiempo límite alcanzado\");\r\n                return this.bestSolution;\r\n            }\r\n\r\n            if (currentTime - lastProgressUpdate > 5000) {\r\n                console.log(`Nodos explorados: ${nodesExplored}`);\r\n                lastProgressUpdate = currentTime;\r\n            }\r\n\r\n            const current = openSet.deq();\r\n            nodesExplored++;\r\n\r\n            // Verificar si hemos completado un tour válido\r\n            if (this.countVisited(current.visited) === this.totalNodes) {\r\n                const finalCost = current.g + this.getDistance(current.currentNode, this.startNode);\r\n                const completePath = [...current.path, this.startNode];\r\n\r\n                if (!this.bestSolution || finalCost < this.bestSolution.totalCost) {\r\n                    this.updateBestSolution({\r\n                        path: completePath,\r\n                        totalCost: finalCost\r\n                    });\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // Explorar vecinos no visitados\r\n            for (let nextNode = 0; nextNode < this.totalNodes; nextNode++) {\r\n                if (current.visited[nextNode]) continue;\r\n\r\n                const distance = this.getDistance(current.currentNode, nextNode);\r\n                const newG = current.g + distance;\r\n\r\n                // Si ya tenemos una mejor solución, podamos esta rama\r\n                if (this.bestSolution && newG >= this.bestSolution.totalCost) {\r\n                    continue;\r\n                }\r\n\r\n                const newVisited = [...current.visited];\r\n                newVisited[nextNode] = true;\r\n\r\n                const newH = this.calculateHeuristic(nextNode, newVisited);\r\n                const newF = newG + newH;\r\n\r\n                // Crear nuevo estado\r\n                const newState = {\r\n                    currentNode: nextNode,\r\n                    visited: newVisited,\r\n                    path: [...current.path, nextNode],\r\n                    g: newG,\r\n                    h: newH,\r\n                    f: newF\r\n                };\r\n\r\n                // Si la estimación total es menor que la mejor solución actual, explora este camino\r\n                if (!this.bestSolution || newF < this.bestSolution.totalCost) {\r\n                    openSet.enq(newState);\r\n                }\r\n            }\r\n\r\n            // Limpieza periódica de la memoria caché de heurísticas\r\n            if (nodesExplored % 1000 === 0) {\r\n                this.memoizedHeuristics.clear();\r\n            }\r\n        }\r\n\r\n        console.log(`Búsqueda completada. Nodos explorados: ${nodesExplored}`);\r\n        return this.bestSolution;\r\n    }\r\n}\r\n\r\n// function solve_tspACO_MST(coords) {\r\n//   console.log('Iniciando TSP con A* y heurística ACO');\r\n//   console.log(`Número de ciudades: ${coords.length}`);\r\n//   const startTime = Date.now();\r\n\r\n//   const solver = new TSP_Solver_AStar(coords);\r\n//   const solution = solver.solve();\r\n\r\n//   const endTime = Date.now();\r\n\r\n//   console.log('\\nResultados finales:');\r\n//   console.log(`Costo total: ${solution.totalCost}`);\r\n//   console.log(`Ruta: ${solution.path.join(' -> ')}`);\r\n  \r\n//   return solution;\r\n// }\r\n\r\n\r\nself.onmessage = function(e) {\r\n    const { type, data } = e.data;\r\n    \r\n    if (type === 'solve') {\r\n        try {\r\n            console.log('Worker: Starting TSP solution');\r\n            const solver = new TSP_Solver_AStar(data);\r\n            const solution = solver.solve();\r\n            \r\n            // Enviar actualizaciones de progreso\r\n            const progressUpdate = {\r\n                type: 'progress',\r\n                data: {\r\n                    nodesExplored: solver.nodesExplored,\r\n                    currentBest: solver.bestSolution?.totalCost\r\n                }\r\n            };\r\n            self.postMessage(progressUpdate);\r\n            \r\n            // Enviar la solución final\r\n            self.postMessage({\r\n                type: 'solution',\r\n                data: solution\r\n            });\r\n        } catch (error) {\r\n            self.postMessage({\r\n                type: 'error',\r\n                data: error.message\r\n            });\r\n        }\r\n    }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [133], () => (__webpack_require__(4228)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","__webpack_require__.amdO = {};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"c2e388aa\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/tsp-solver/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t613: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunktsp\"] = self[\"webpackChunktsp\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(133).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DisjointSet","constructor","size","this","parent","Array","from","length","_","i","rank","fill","find","x","union","y","rootX","rootY","AntColony","distanceMatrix","numAnts","arguments","undefined","iterations","evaporationRate","alpha","beta","numCities","pheromoneMatrix","map","bestTourLength","Infinity","bestTour","runIteration","startCity","visitedNodes","bestIterationLength","ant","tour","constructSolution","tourLength","calculateTourLength","updatePheromones","available","forEach","node","currentCity","nextCity","selectNextCity","push","probabilities","totalProbability","city","probability","Math","pow","random","sum","j","pheromoneDeposit","to","HybridHeuristic","antColony","weightMST","weightACO","calculateMSTCost","unvisitedNodes","edges","n","node1","node2","v","w","weight","sort","a","b","ds","mstCost","edgesUsed","neededEdges","edge","calculateACOCost","currentNode","getMinUnvisitedDistance","minDistance","dist","calculateHybridHeuristic","visited","reduce","acc","mstHeuristic","acoCost","adjustWeights","mstSuccess","acoSuccess","min","TSP_Solver_AStar","locations","graph","createCompleteGraph","startNode","totalNodes","memoizedHeuristics","Map","timeLimit","startTime","Date","now","bestSolution","lastUpdate","createDistanceMatrix","hybridHeuristic","initialVisited","mstSuccesses","acoSuccesses","totalAttempts","matrix","math","Graph","directed","numLocations","setEdge","getDistance","visitedToString","join","calculateHeuristic","memoKey","cached","get","heuristicValue","set","countVisited","count","updateBestSolution","solution","currentTime","console","log","totalCost","toFixed","findInitialSolution","path","nearestNode","distance","solve","openSet","PriorityQueue","f","startState","g","h","enq","nodesExplored","lastProgressUpdate","isEmpty","current","deq","nextNode","newG","newVisited","newH","newF","newState","clear","finalCost","completePath","self","onmessage","e","type","data","_solver$bestSolution","solver","progressUpdate","currentBest","postMessage","error","message","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","amdD","Error","amdO","deferred","result","chunkIds","fn","priority","notFulfilled","fulfilled","Object","keys","every","key","splice","r","getter","__esModule","d","definition","o","defineProperty","enumerable","chunkId","Promise","all","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}